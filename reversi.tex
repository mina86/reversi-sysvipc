\documentclass[a4paper,12pt,twoside]{report}
\usepackage[MeX]{polski}
\usepackage[latin2]{inputenc}

\usepackage{listings}
\lstdefinelanguage{pseudo}{morekeywords={DEFINE,AS,IF,ELSE,WHILE,DO,
    RETURN,BREAK,true,false,NOT}, sensitive=true,
  mathescape=true, morecomment=[s]{/*}{*/},
  literate={:=}{{$\gets$}}1 {<=}{{$\leq$}}1 {>=}{{$\geq$}}1
  {!=}{{$\neq$}}1 {==}{{$=$}}1 {NOT }{$\neg$}1}
\lstset{language=pseudo, basicstyle=\small, numbers=left,
  numberstyle=\tiny, stepnumber=1, numbersep=5pt, numberblanklines=false,
  breaklines=true, breakindent=20pt, extendedchars=true, frameround=fttt,
  aboveskip=12pt, belowskip=12pt, tabsize=8, showtabs=false}

%%
%% Penalties
%%
%\overfullrule = 3mm       % zaznacz linijki z nadmiarami czarn± sztabk±
\exhyphenpenalty = 999999 % s³owa z³o¿one nie przeno¶ na ³±czniku
\righthyphenmin = 3       % nie dziel xx-, ale xxx-
\widowpenalty = 999999    % ostatnia linia akapitu nie zacznie strony
\clubpenalty = 999999     % pierwsza linia akapitu nie zacznie strony
%\clubpenalty = 9950  % pierwsza linia akapitu wyj±tkowo mo¿e koñczyæ stronê
\hfuzz = 0pt              % znaki nie mog± sterczeæ na margines
%\hfuzz = 3pt              % znaki mog± sterczeæ na margines do wielko¶ci 3pt
\tolerance 600            % zwiêkszamy toleracjê
\pretolerance 300         % oraz pretolerancjê
\doublehyphendemerits = 99999 %% zniechêcamy TeX-a do dzielenia wyrazów


\renewcommand\thesection{}
\renewcommand\thesubsection{}


%% Margins
\addtolength{\topmargin}{-20pt}
\addtolength{\textheight}{40pt}
%\addtolength{\leftmargin}{-20pt}
%\addtolength{\rightmargin}{-20pt}
%\addtolength{\textwidth}{40pt}


%%
%% Modify page headers and footers
%%
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\lhead[\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
      \normalfont \small\bfseries\thepage}]
     {\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
      \normalfont \small\bfseries\rightmark}}
\rhead[\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
     \normalfont \small\bfseries{Reversi}}]
    {\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
     \normalfont \small\bfseries\thepage}}
\cfoot[]{}
\addtolength{\headheight}{1.6pt}


\title{Reversi}
\author{Micha³ Nazarewicz}


\begin{document}

\maketitle

\newpage
\section{Opis projektu}

Projekt polega na napisaniu dwu osobowej gry dzia³aj±cej pod kontrol±
uniksopodobnego systemu.  W~programie obecny jest serwer, który
nadzoruje rozgrywkê oraz dwa klienty, które komunikuj± siê z~serwerem
i~umo¿liwiaj± uczestnictwo w~rozgrywce.

Zaimplementowan± gr± jest gra Reversi (znana równie¿ pod nazw±
Othello) rozgrywana na planszy o~wymiarach $8 \times 8$, w~której
gracze wykonuj±c naprzemienne ruchy staraj± siê zape³niæ planszê jak
najwiêksz± liczb± pionów swojego koloru.

Procesy porozumiewaj± siê za pomoc± pamiêci wspó³dzielonej i~semaforów
realizowanych przy u¿yciu interfejsów Systemu V.  Na pocz±tku serwer
inicjuje potrzebne zasoby i~za pomoc± kolejki zaimplementowanej na
semaforach oczekuje na ,,pod³±czenie'' dwóch klientów, którym nadaje
numery i~rozpoczyna rozgrywkê.

Mo¿liwe jest uruchomienie serwera na pierwszym planie---i~wówczas
wypisuje on informacje o~tym co siê dzieje w~grze---lub
w~tle---i~wówczas {\it forkuje} siê, aby zacz±æ dzia³aæ w~tle.
Podobnie klient---mo¿e byæ uruchomiony w~trybie, gdzie u¿ytkownik
decyduje o~ruchach albo w~trybie, gdzie komputer steruje ruchami
i~wówczas mo¿na uruchomiæ go w~tle.


\section{Zasady gry}

Gra rozgrywana jest na planszy $8 \times 8$.  Ka¿dy z~dwóch graczy ma
do dyspozycji pionki swojego koloru.  Pocz±tkowo na planszy znajduj±
siê po dwa pionki ka¿dego z~graczy, u³o¿one na ¶rodkowych czterech
polach tak, ¿e pionki tego samego gracza le¿± na polach stykaj±cych
siê rogiem.

W~trakcie rozrywki, gracze uk³adaj± na przemian pionki w³asnego koloru
na wolnych polach planszy do momentu, a¿ plansza zostanie ca³kowicie
zape³niona lub ¿aden z~graczy nie bêdzie móg³ wykonaæ dozwolonego
ruchu.

Dozwolony ruch to taki, w~którym pionek jest u³o¿ony na polu, które
znajduje siê w linii (poziomej, pionowej lub uko¶nej) z~innym pionkiem
gracza wykonuj±cego ruch, i~na wszystkich polach pomiêdzy wybranym
polem a~tym pionkiem znajduj± siê pionki przeciwnika.  Te pionki
zostaj± po wykonaniu ruchu przejête i~zmieniaj± kolor na przeciwny
(tzn. na kolor pionków gracza, który wykonuje ruch).

Je¶li gracz nie mo¿e wykonaæ dozwolonego ruchu, traci automatycznie
kolejkê.

Wygrywa ten z graczy, którego wiêksza liczba pionków znajduje siê na
planszy po zakoñczeniu gry; je¶li liczba pionków graczy jest
jednakowa, nastêpuje remis.

{\small Opis zasad zaczerpniêty z~serwisu kurnik.pl.}


\newpage
\section{Algorytmy}

Procesy obecne w~grze wspó³dziel± miêdzy sob± nastêpuj±ce zasoby:

\vspace{1em}
\begin{tabular}{ll}
{\tt msg}            & identyfikator przesy³anej wiadomo¶ci \\
{\tt data}           & dane przypisane do wiadomo¶ci \\
{\tt map}            & zapis stanu planszy \\
{\tt sem\_init}      & semafor inicjuj±cy \\
{\tt sem\_server}    & semafor serwera \\
{\tt sem\_player[2]} & dwaa semafory -- jeden dla ka¿dego gracza \\
\end{tabular}
\vspace{1em}

\subsection{Serwer}

Po zainicjowaniu wspó³dzielonych zasobów serwer postêpuje wed³ug
nastêpuj±cego algorytmu:

\begin{lstlisting}
DEFINE sendMsgTo(semaphore)
	up(semaphore)
	down(sem_server)

DEFINE sendReadMap
	msg := READ_MAP
	up(sem_player[0])
	up(sem_player[1])
	down(sem_server)
	down(sem_server)


/* Czekaj na klienty i przypisz im numery  */
data := 0
sendMsgTo(sem_init)
data := 1
sendMsgTo(sem_init)

/* Zainicjuj mapê */
map := pocz±tkowy stan mapy
sendReadMap

/* W³a¶ciwa rozgrywka */
player := 1
WHILE kto¶ mo¿e wykonaæ ruch
	player := 1 - player
	IF NOT gracz player mo¿e wykonaæ ruchu
		player := 1 - player

	/* Odczytaj ruch klienta */
	DO
		msg := MAKE_MOVE
		sendMstTo(sem_player[player])
	WHILE NOT data opisuje poprawny ruch

	/* Uaktualnij planszê */
	uaktualnij planszê zgodnie z ruchem data
	sendReadMap

/* Koniec gry, og³o¶ wynik */
data := zwyciêzca gry
msg  := GAME_OVER
up(sem_player[0])
up(sem_player[1])
down(serwer)
down(serwer)
\end{lstlisting}

\subsection{Klient}

Tymczasem klienty postêpuj± wg nastêpuj±cego schematu:

\begin{lstlisting}
/* Odczytaj swój numer */
down(sem_init);
player := data
up(sem_server)

/* Rozgrywka */
done := false
WHILE NOT done
	down(sem_player[player])
	IF msg == READ_MAP
		uaktualnij i~wy¶wietl planszê
	ELSE IF msg == MAKE_MOVE
		data := zdecyduj gdzie poruszyæ
	ELSE IF msg == GAME_OEVR
		winner := data
		done := true
	up(sem_server)

/* Gra zakoñczona */
wypisz informacje o zwyciêzcy (zapisana w winner)
\end{lstlisting}


\newpage

\end{document}

