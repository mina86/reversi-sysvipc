\documentclass[a4paper,11pt,twoside]{mwart}
\usepackage[MeX]{polski}
\usepackage[latin2]{inputenc}
\usepackage{graphicx}

\usepackage{listings}
\lstdefinelanguage{pseudo}{morekeywords={DEFINE,AS,IF,ELSE,WHILE,DO,
    RETURN,BREAK,true,false,NOT}, sensitive=true,
  mathescape=true, morecomment=[s]{/*}{*/},
  literate={:=}{{$\gets$}}1 {<=}{{$\leq$}}1 {>=}{{$\geq$}}1
  {!=}{{$\neq$}}1 {==}{{$=$}}1 {NOT }{$\neg$}1}
\lstset{language=pseudo, basicstyle=\small, numbers=left,
  numberstyle=\tiny, stepnumber=1, numbersep=5pt, numberblanklines=false,
  breaklines=true, breakindent=20pt, extendedchars=true, frameround=fttt,
  aboveskip=12pt, belowskip=12pt, tabsize=8, showtabs=false}

%%
%% Modify page headers and footers
%%
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\lhead[\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
      \normalfont \small\bfseries\thepage}]
     {\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
      \normalfont \small\bfseries\rightmark}}
\rhead[\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
     \normalfont \small\bfseries{Reversi}}]
    {\fancyplain{}{\renewcommand\familydefault{\rmdefault}%
     \normalfont \small\bfseries\thepage}}
\cfoot[]{}
\addtolength{\headheight}{1.6pt}


\title{Reversi}
\author{Micha³ Nazarewicz}



\begin{document}

\thispagestyle{empty}

\vspace{60pt}
\centerline{\bf \Huge{Reversi}}
\vspace{30pt}
\centerline{\Large Micha³ Nazarewicz}
\vspace{10pt}
\centerline{M.Nazarewicz@stud.elka.pw.edu.pl}
\vspace{30pt}
\centerline{\today}
\vspace{60pt}

\tableofcontents
\listoffigures


\newpage
\newpage
\section{Opis projektu}\label{opis}

Projekt polega na napisaniu dwu osobowej gry dzia³aj±cej pod kontrol±
uniksopodobnego systemu.  W~programie obecny jest serwer, który
nadzoruje rozgrywkê oraz dwa klienty, które komunikuj± siê z~serwerem
i~umo¿liwiaj± uczestnictwo w~rozgrywce.

Zaimplementowan± gr± jest gra Reversi (zwana równie¿ pod nazw±
Othello\texttrademark) rozgrywana na planszy o~wymiarach $8 \times 8$,
w~której gracze wykonuj±c naprzemienne ruchy staraj± siê zape³niæ
planszê jak najwiêksz± liczb± pionów swojego koloru.

\subsection{Zasady gry Reversi}\label{zasady}

Gra rozgrywana jest na planszy $8 \times 8$.  Ka¿dy z~dwóch graczy ma
do dyspozycji pionki swojego koloru.  Pocz±tkowo na planszy znajduj±
siê po dwa pionki ka¿dego z~graczy, u³o¿one na ¶rodkowych czterech
polach tak, ¿e pionki tego samego gracza le¿± na polach stykaj±cych
siê rogiem.

W~trakcie rozrywki, gracze uk³adaj± na przemian pionki w³asnego koloru
na wolnych polach planszy do momentu, a¿ plansza zostanie ca³kowicie
zape³niona lub ¿aden z~graczy nie bêdzie móg³ wykonaæ dozwolonego
ruchu.

Dozwolony ruch to taki, w~którym pionek jest u³o¿ony na polu, które
znajduje siê w linii (poziomej, pionowej lub uko¶nej) z~innym pionkiem
gracza wykonuj±cego ruch, i~na wszystkich polach pomiêdzy wybranym
polem a~tym pionkiem znajduj± siê pionki przeciwnika.  Te pionki
zostaj± po wykonaniu ruchu przejête i~zmieniaj± kolor na przeciwny
(tzn. na kolor pionków gracza, który wykonuje ruch).

Je¶li gracz nie mo¿e wykonaæ dozwolonego ruchu, traci automatycznie
kolejkê.

Wygrywa ten z graczy, którego wiêksza liczba pionków znajduje siê na
planszy po zakoñczeniu gry; je¶li liczba pionków graczy jest
jednakowa, nastêpuje remis.

{\small Opis zasad zaczerpniêty z~serwisu kurnik.pl.}



\newpage
\section{Funkcjonalno¶æ i~interfejs u¿ytkownika}

W~rozgrywce bior± udzia³ trzy procesy: serwer oraz dwa klienty.
Serwer mo¿e zostaæ uruchomiony w~tle lub na pierwszym planie.  W~tym
drugim przypadku widoczne s± komunikaty informuj±ce o~akcjach
powziêtych przez serwer (oczekiwanie na graczy, na wykonanie ruchu,
og³oszenie wyniku itp).

Klient mo¿e byæ sterowany przez cz³owieka lub komputer.  Dodatkowo, w drugim
trybie mo¿e byæ uruchomiony w~tle lub na pierwszym planie i~wówczas
pozwala na ¶ledzenie stanu rozgrywki.


\subsection{Uruchamianie programów}

Program uruchamiany jest z~linii poleceñ.  Przyjmuje dwa argumenty:
tryb pracy oraz klucz rozgrywki.  Uruchomiony z~niepoprawn± liczb±
argumentów lub z~nieznanym trybem lub b³êdnym kluczem program wypisuje
nastêpuj±cy ekran pomocy (przedstawiony na rysunku \ref{fig:pomoc}).
Jak ju¿ wspomniano, dostêpnych jest piêæ trybów pracy:

\begin{description}
\item[{\tt server}] serwer na pierwszym planie,
\item[{\tt daemon}] serwer w~tle,
\item[{\tt client}] klient sterowany przez u¿ytkownika,
\item[{\tt ncp}]    (od ang.\ {\it Non Playable Character}) klient
                    sterowany przez komputer jednak poniewa¿
                    uruchomiony jest na pierwszym planie umo¿liwia
                    ¶ledzenie rozgrywki oraz
\item[{\tt ncpd}]   klient sterowany przez komputer dzia³aj±cy w~tle.
\end{description}

\begin{figure}[btp]
\begin{verbatim}
usage: reversi <mode> <key>
<mode> is one of:
  server     server running in foreground
  daemon     server running as a daemon in background
  client     client controlled by human
  ncp        client controlled by computer
  ncpd       client controlled by computer running in background
\end{verbatim}
\caption{Pomoc wypisywana po uruchomieniu programu z~b³êdnymi argumentami.}\label{fig:pomoc}
\end{figure}


Drugi argument--klucz gry--jest kluczem wykorzystywanym przy tworzeniu
(w~przypadku serwera) i~uzyskiwaniu dostêpu do (w~przypadku klientów)
zasobów wspó³dzielonych.  Klucz ten pozwala identyfikowaæ dan±
rozgrywkê i~prowadziæ wiele gier jednocze¶nie--aby do³±czyæ siê do
gry u¿ytkownik musi znaæ jej klucz.


\subsection{Serwer}

Serwer uruchomiony na pierwszym planie wypisuje ró¿ne komunikaty
informuj±ce o~tym co obecnie robi (widoczne na rysunku
\ref{fig:serwer}).  Informacje te maj± g³ównie zastosowanie przy
sprawdzaniu poprawno¶ci dzia³ania programu i~dlatego serwer mo¿e byæ
uruchomiony równie¿ w~tle.  Serwer dzia³a w~pêtli: czeka na graczy
i~nadzoruje rozgrywkê.  Gdy runda siê zakoñczy wraca do pocz±tku
i~czeka na kolejn± parê graczy.  Robi tak do momentu, gdy zostanie
zatrzymany poprzez sygna³ (np.\ {\tt SIGINT}, {\tt SIGQUIT} lub {\tt
  SIGTERM}).


\begin{figure}[btp]
\begin{verbatim}
Waiting for players...
Got player one...
Got player two...
Waiting for player one...
Waiting for player two...
\end{verbatim}
i~tak dalej, a¿ gra siê zakoñczy
\begin{verbatim}
Waiting for player two...
Waiting for player one...
Player one wins
\end{verbatim}
i~rozpoczyna siê nastêpna rozgrywka.

\caption{Komunikaty wypisywane przez serwer.}\label{fig:serwer}
\end{figure}


\subsection{Klient}

Klient, o~ile nie zosta³ uruchomiony w~tle, zanim gra siê rozpocznie,
wypisuje informacje o~tym co robi (rysunek \ref{fig:klient-start}),
a~gdy rozgrywka siê rozpocznie wy¶wietla w~trybie tekstowym kolorow±
planszê, na której odbywa siê gra (rysunek \ref{fig:klient-plansza}).

W~trybie sterowani przez cz³owieka, u¿ytkownik mo¿e poruszaæ migaj±cym
kursorem wykorzystuj±c strza³ki, cyfry {\it 8246} (jak na klawiaturze
numerycznej), przyciski {\it wsad}, {\it pnbf} jaki i {\it pnbf}
z~wci¶niêtym kontrolem (zgodnie ze sterowaniem w~Emacsie) oraz {\it
  hjkl} (zgodnie ze sterowaniem w~edytorze vi).  Wci¶niêcie entera lub
spacji powoduje wybranie danej pozycji.  W~trakcie, przemieszczania
kursora program pokazuje jak wygl±da³aby plansza po wykonaniu danego
ruchu.

\begin{figure}[btp]
\begin{verbatim}
Waiting for server to be ready...
You are player one
Waiting for game to start...
\end{verbatim}
\caption{Komunikaty wypisywane przez klienta przed rozpoczêciem
  rozgrywki.}\label{fig:klient-start}
\end{figure}


\begin{figure}[btp]
\begin{verbatim}
  A B C D E F G H
1 . . . . . . . . 1
2 . . . . X O . . 2
3 . . . . X . . . 3
4 . . O X X . . . 4
5 . . X O O O . . 5
6 . . . . . . . . 6
7 . . . . . . . . 7
8 . . . . . . . . 8
  A B C D E F G H

You are O
\end{verbatim}
\caption{Widok planszy po wykonaniu kilku
  ruchów.}\label{fig:klient-plansza}
\end{figure}



\newpage
\section{Podzia³ na modu³y}

Na kwestiê podzia³u na modu³y mo¿na patrzeæ na dwa sposoby: albo
analizuj±c pojedynczy proces, albo patrz±c ca³o¶ciowo na ca³±
rozgrywkê.  W~pierwszym przypadku mamy podstawow± czê¶æ programu
analizuj±c± argumenty wywo³ania i~przygotowuj±c± zasoby wspó³dzielone
oraz w³a¶ciw± czê¶æ, w~której wykonywana jest logika gry.  W~drugim
przypadku mamy jeden serwer i~dwa klienty porozumiewaj±ce siê poprzez
zasoby wspó³dzielone.


\subsection{Pojedynczy proces}

Po uruchomieniu programu sprawdzane i~interpretowane s± argumenty
wywo³ania.  Je¿eli s± one poprawne nastêpuje przygotowanie zasobów
wspó³dzielonych.  Dodatkowo, je¿eli wybrano tryb pracy w~tle nastêpuje
przej¶cie w~t³o wraz z~utrat± terminala steruj±cego, zamkniêciem
niepotrzebnych deskryptorów plików i~przekierowanie wyj¶cia i~wej¶cia
do/z~{\tt/dev/null}.  Gdy to wszystko siê dokona, zale¿nie od
wybranego trybu wywo³ywana jest funkcja serwera lub klienta.

Korzystaj±c z uzyskanych zasobów wspó³dzielonych, uruchomiona
procedura wype³nia swoje zadanie, a¿ do momentu, gdy siê zakoñczy lub
zostanie przerwana (czy to na skutek zakoñczenia gry, czy to b³êdnej
sytuacji, czy te¿ otrzymania sygna³u).

Wówczas sterowanie wraca ponownie do podstawowej czê¶ci programu,
która odpowiedzialna jest za zwolnienie zasobów
wspó³dzielonych--klienty jedynie je oddaj±, a~serwer niszczy.


\subsection{Ca³o¶ciowa rozgrywka}

Analizuj±c ca³± grê mo¿na wyró¿niæ trzy modu³y: serwer i~dwa klienty.
Porozumiewaj± siê one przez zasoby wspó³dzielone: trzy ,,kolejki''
(patrz sekcja \ref{kolejki}) oraz zapis planszy (dok³adny opis sposobu
komunikacji opisany jest w~sekcji \ref{komunikacja}).  Ca³o¶æ
przedstawiona jest na rysynku \ref{fig:moduly}.

\begin{figure}[btp]
\centering
\includegraphics[width=\textwidth]{modules.eps}
\caption{Podzia³ na modu³y i~komunikacja}\label{fig:moduly}
\end{figure}

Kolejka iniciuj±ca wykorzystywana jest tylko przy starcie klienta, aby
ten móg³ odczytaæ, którym jest klientem--czy pierwszym czy drugim.
W~dalszej czê¶ci rozgrywki kolejka ta nie jest wykorzystywana.

Gdy klient dostaje komunikat na swojej kolejce od razu go obs³uguje,
odczytuje stan planszy je¶li jest to konieczne, wykonuje wszelkie
operacje, których od niego oczekuj± i~odsy³a odpowied¼.  Serwer
odczytuje przekazane informacje (je¶li jakie¶ s±), analizuje dane
i~przesy³a kolejn± wiadomo¶æ do jednego z~klientów.

Klienty nigdy nie porozumiewaj± siê bezpo¶rednio miêdzy sob±.  Co
wiêcej, wykonuj± dzia³ania na zasobach wspó³dzielonych tylko
i~wy³±cznie, po otrzymaniu komunikatu od serwera zanim ode¶l±
odpowied¼.  Poniewa¿ serwer zazwyczaj wysy³a wiadomo¶æ tylko do
jednego z~klientów (s± dwa wyj±tki od tej regu³y opisane w~sekcji
\ref{kolejki}) przewa¿nie, tylko jeden klient odczytuje dane
z~wspó³dzielonej pamiêci, dziêki czemu nie ma obawy o~zniszczenie
danych poprzez wy¶cigi.


\newpage
\section{Komunikacja i~algorytmy}\label{komunikacja}

Jak ju¿ zosta³o powiedziane wymiana informacji, a~tak¿e synchronizacja
jest zapewniana poprzez specyficzne kolejki, których u¿ycie przypomina
mechanizm RPC (ang.\ {\it Remote Procedure Call})--serwer wysy³a
komunikat i~wówczas sterowanie przechodzi do klienta, który obs³uguje
wiadomo¶æ i~wysy³a odpowied¼, w~którym to momencie sterowanie wraca do
serwera.

\subsection{Kolejki}\label{kolejki}

Pojedyncza kolejka sk³ada siê z~dwóch semaforów--serwera
i~klienta--pola typu wiadomo¶ci i~pola danych.  Klient opuszcza swój
semafor, który jest podnoszony, gdy serwer wpisze odpowiednie dane.
Wówczas klient mo¿e odczytaæ komunikat, wykonaæ odpowiednie operacje,
zapisaæ odpowied¼ i~podnie¶æ semafor serwera, na którym rzeczony
zasn±³ zaraz po wys³aniu wiadomo¶ci.  Rysunek \ref{fig:kolejka}
przedstawia zapis sekwencji operacji wykonywanych przy przesy³aniu
komunikatów.

\begin{figure}[btp]
\centering

\begin{picture}(320,200)(0,0)
\put( 30,180){\line(0,-1){180}}\put(  0,180){\framebox(60,20){\bf Serwer}}
\put( 95,180){\line(0,-1){180}}\put( 65,180){\framebox(60,20){\small{Sem. serwera}}}
\put(160,180){\line(0,-1){180}}\put(130,180){\framebox(60,20){Dane}}
\put(225,180){\line(0,-1){180}}\put(195,180){\framebox(60,20){\small{Sem. klienta}}}
\put(290,180){\line(0,-1){180}}\put(260,180){\framebox(60,20){\bf Klient}}

\put( 30, 150){\vector( 1,0){130}}\put( 30, 150){\makebox(130,10){Zapisz wiadomo¶æ}}
\put(290, 150){\vector(-1,0){ 65}}\put(225, 150){\makebox( 65,10){Opu¶æ}}
\put( 30, 130){\vector( 1,0){195}}\put( 30, 130){\makebox(195,10){Podnie¶}}
\put( 30, 110){\vector( 1,0){ 65}}\put( 30, 110){\makebox( 65,10){Opu¶æ}}
\put(290, 110){\vector(-1,0){130}}\put(160, 110){\makebox(130,10){Odczytaj wiadomo¶æ}}

\put(260,  80){\makebox(60,10){Przetwórz wiadomo¶æ}}

\put(290,  60){\vector(-1,0){130}}\put(160,  60){\makebox(130,10){Zapisz odpowied¼}}
\put(290,  40){\vector(-1,0){195}}\put( 95,  40){\makebox(195,10){Podnie¶}}
\put( 30,  20){\vector( 1,0){130}}\put( 30,  20){\makebox(130,10){Odczytaj odpowied¼}}
\put(290,  20){\vector(-1,0){ 65}}\put(225,  20){\makebox( 65,10){Opu¶æ}}

\end{picture}

\caption{Implementacja kolejki na semaforach i~pamiêci wspó³dzielonej.}\label{fig:kolejka}
\end{figure}

Ju¿ wcze¶niej wspomniano o~dwóch wyj±tkach.  S± to komunikaty
informuj±ce o~zmianie stanu planszy oraz o~zakoñczeniu gry.  Z~powodów
wydajno¶ciowych s± one wysy³ane do obu klientów jednocze¶nie, aby na
maszynach weieloprocesorowych lub wielordzeniowych mog³y byæ
przetwarzane równocze¶nie przez oba klienty.  Jest to jedyna sytuacja,
gdy sterowanie ,,rozdziela siê na dwoje'' i~z~tego powodu klienty nie
maj± prawa modyfikowaæ pamiêci wspó³dzielonej.  Rysunek
\ref{fig:kolejka2} przedstawia uproszczony schemat wysy³ania tych
komunikatów.


\begin{figure}[btp]
\centering

\begin{picture}(320,200)(0,0)
\put( 30,180){\line(0,-1){180}}\put(  0,180){\framebox(60,20){\bf Klient 1}}
\put( 95,180){\line(0,-1){180}}\put( 65,180){\framebox(60,20){Dane 1}}
\put(160,180){\line(0,-1){180}}\put(130,180){\framebox(60,20){\bf Serwer}}
\put(225,180){\line(0,-1){180}}\put(195,180){\framebox(60,20){Dane 2}}
\put(290,180){\line(0,-1){180}}\put(260,180){\framebox(60,20){\bf Klient 2}}

\put(  0, 160){\makebox(60,10){Za¶nij}}
\put(260, 160){\makebox(60,10){Za¶nij}}

\put(160, 160){\vector(-1,0){ 65}}\put( 95, 160){\makebox( 65,10){Zapisz}}
\put(160, 140){\vector( 1,0){ 65}}\put(160, 140){\makebox( 65,10){Zapisz}}
\put(160, 120){\vector(-1,0){130}}\put( 30, 120){\makebox(130,10){Obud¼}}
\put(160, 100){\vector( 1,0){130}}\put(160, 100){\makebox(130,10){Obud¼}}
\put(130,  80){\makebox(60,10){Za¶nij}}
\put(130,  60){\makebox(60,10){Za¶nij}}

\put( 30, 100){\vector( 1, 0){ 65}}\put( 30, 100){\makebox( 65, 10){Odczytaj}}
\put(290,  80){\vector(-1, 0){ 65}}\put(235,  80){\makebox( 65, 10){Odczytaj}}
\put(  0,  70){\makebox(60,10){Przetwórz wiadomo¶æ}}
\put(260,  50){\makebox(60,10){Przetwórz wiadomo¶æ}}
\put( 30,  40){\vector( 1, 0){130}}\put( 30,  40){\makebox( 65, 10){Obud¼}}
\put(290,  20){\vector(-1, 0){130}}\put(170,  20){\makebox( 65, 10){Obud¼}}
\put(  0,  20){\makebox(60,10){Za¶nij}}
\put(260,   0){\makebox(60,10){Za¶nij}}
\end{picture}

\caption{Wysy³anie wiadomo¶ci do dwóch klientów na raz.}\label{fig:kolejka2}
\end{figure}


\subsection{Zasoby wspó³dzielone}

Poniewa¿ komunikaty zawsze id± od strony serwera do klienta
(odpowiedzi nie traktujemy jak komunikatu) i~co wiêcej, sterowanie
jest w~dwóch miejscach jednocze¶nie tylko w~przypadku, gdy obs³u¿enie
wiadomo¶ci nie wymaga modyfikowania danych wspó³dzielonych, semafor
serwera i~pole danych (tak naprawdê rozdzielone na pole typu
wiadomo¶ci i~pole danych) ze wszystkich trzech kolejek s±
uwspólnione.  Zmniejsza to listê potrzebnych zasobów wspó³dzielonych
do nastêpuj±cych pozycji:

\begin{tabular}{ll}
{\tt msg}            & identyfikator przesy³anej wiadomo¶ci \\
{\tt data}           & dane przypisane do wiadomo¶ci \\
{\tt map}            & zapis stanu planszy \\
{\tt sem\_init}      & semafor inicjuj±cy \\
{\tt sem\_server}    & semafor serwera \\
{\tt sem\_player[2]} & dwa semafory -- jeden dla ka¿dego gracza \\
\end{tabular}


\subsection{Komunikaty}

Serwer przesy³a do klientów nastêpuj±ce komunikaty:

\begin{description}
\item{\tt MAKE\_MOVE} serwer oczekuje od klienta wykonania ruchu.
  W~odpowiedzi klient zapisuje w~polu danych ({\tt data}) pozycje, na
  któr± chce siê poruszyæ.
\item{\tt READ\_MAP} serwer informuje klienty o~zmianie stany
  planszy.  Je¿eli klient wy¶wietla stan planszy na ekranie powinien
  go uaktualniæ.  W~trakcie obs³ugi tego komunikatu klienty nie maj±
  prawa modyfikowaæ danych wspó³dzielonych.
\item{\tt GAME\_OVER} serwer informuje klienty o~zakoñczeniu gry.
  W~polu danych ({\tt data}) zapisany jest zwyciêzca ($0$ i~$1$
  oznaczaj± graczy, $2$ oznacza remis).  W~trakcie obs³ugi tego
  komunikatu klienty nie maj± prawa modyfikowaæ danych
  wspó³dzielonych.
\end{description}


\subsection{Algorytmy}

Gdy ju¿ zasoby wspó³dzielone zostan± zainicjowane, poszczególne
procesy zaczynaj± dzia³aæ wed³ug nastêpuj±cych algorytmów:


\subsubsection{Serwer}

\begin{lstlisting}
DEFINE send {message} to {player}
	msg := message
	up sem_player[player]
	down sem_server

DEFINE send {message} to both
	msg := message
	up sem_player[0], up sem_player[1]
	down sem_server, down sem_server


data := 0, send 0 to sem_init /* Czekaj na klienty i */
data := 1, send 0 to sem_init /* przypisz im numery  */

map := pocz±tkowy stan mapy   /* Zainicjuj mapê */
send READ_MAP to both

player := 1                   /* W³a¶ciwa rozgrywka */
WHILE kto¶ mo¿e wykonaæ ruch
	player := 1 - player
	IF NOT gracz player mo¿e wykonaæ ruchu
		player := 1 - player

	DO                    /* Odczytaj ruch klienta */
		send MAKE_MAKE to player
	WHILE NOT data opisuje poprawny ruch

	uaktualnij planszê    /* Przyjmij ruch */
	send READ_MAP to both

data := zwyciêzca gry         /* Koniec gry, og³o¶ wynik */
send GAME_OVER to both
\end{lstlisting}

\subsubsection{Klient}

\begin{lstlisting}
/* Odczytaj swój numer */
down sem_init
player := data
up sem_server

/* Rozgrywka */
done := false
WHILE NOT done
	down sem_player[player]
	IF msg == READ_MAP
		uaktualnij i~wy¶wietl planszê
	ELSE IF msg == MAKE_MOVE
		data := zdecyduj gdzie poruszyæ
	ELSE IF msg == GAME_OEVR
		winner := data
		done := true
	up sem_server

/* Gra zakoñczona */
wypisz informacje o zwyciêzcy (zapisana w winner)
\end{lstlisting}


\newpage
\section{Sytuacje nadzwyczajne}

W~trakcie rozgrywki mo¿e nast±piæ kilka sytuacji nadzwyczajnych, które
procesy powinny obs³u¿yæ.  S± to: wys³anie sygna³y do serwera,
niespodziewana ¶mieræ klienta oraz niespodziewana ¶mieræ serwera.

\paragraph{Sygna³y}

Serwer przechwytuje sygna³y {\tt SIGINT}, {\tt SIGQUIT} oraz {\tt
  SIGTERM} i~po ich otrzymaniu wypisuje komunikat, wpierw niszczy
stworzone przez siebie zasoby wspó³dzielone (pamiêæ i~semafory), aby
ostatecznie zakoñczyæ swoje dzia³anie.  Dziêki obs³udze tych sygna³ów
po rozgrywce nie pozostaj± nieu¿ywane zasoby wspó³dzielone, a~klienty
mog± wykryæ zaistnia³± sytuacjê.

\paragraph{¦mieræ klienta}

Sytuacja, gdy klient zakoñczy dzia³anie jest najtrudniejsza do
wykrycia.  Problem zosta³ rozwi±zany w~ten sposób, ¿e serwer kiedy
tylko ¶pi na semaforze budzi siê co sekundê, aby wys³aæ sygna³ zero do
obu klientów--klienty podaj± swój PID, gdy do³±czaj± siê do gry.
Je¿eli wys³anie sygna³u siê nie powiedzie serwer wypisuje komunikat
o~b³êdzie i~koñczy swoje dzia³anie.

\paragraph{¦mieræ serwera}

Jak to zosta³o opisane w~powy¿szym paragrafie, je¿eli serwer z~jakich¶
powodów zakoñczy swoje dzia³anie przed koñcem rozgrywki, zwolni on
stworzone przez siebie zasoby wspó³dzielone, a~w~tym i~zbiór
semaforów.  Klient, który aktualnie zasn±³ na semaforze od razu
zostanie poinformowany o~ich zniszczeniu.  Je¿eli natomiast klient
w~danej chwili obs³uguje jak±¶ wiadomo¶æ (np.\ czeka a¿ u¿ytkownik
dokona ruchu) zostanie on poinformowany o~b³êdzie w~momencie, gdy
spróbuje podnie¶æ semafor serwera odsy³aj±c do niego odpowied¼.  W~obu
przypadkach klient wypisze komunikat o~b³êdzie i~zakoñczy swoje
dzia³anie.


\end{document}

